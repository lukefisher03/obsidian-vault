**1.** Create your own histogram of how often each philosopher gets to eat with respect to each algorithm. In your histogram, CLEARLY indicate which bars correspond to each of the four programs you wrote.  Include your histogram in the PDF.  Clearly indicate the meanings of the x and y axes and indicate which bars correspond to each of the four algorithm/problem pairs you coded. (5 points)
- See corresponding bar graph.![[Dining Philosophers.png]]
   
**2**. Do you think that it is possible to _prove_ that none of these solutions deadlock with the experimental data you collected? Why or why not?  If you think you can, why do you think the data is sufficient.  If you think you cannot, then what COULD you do to offer such a proof? (5 points)
- Yes, each solution guarantees that no two philosophers will be relying on the other to release a fork in order to eat. Each algorithm sufficiently manages the forks among the philosophers so that all the meals will be eaten. The fairness of an individual algorithm, that is whether or not each philosopher eats the same number of meals, may vary.

**3.** What would you need to do to establish that the arbiter (waiter) solution to this problem is FREE of starvation? Starvation occurs when one or more threads never get to run in their critical sections.  In the example problem, it would correspond to a philosopher never being allowed to eat.  How might you go about proving that the arbiter solution is STARVATION FREE.  You don’t need to provide a formal proof, but do provide a discussion of what facts you would need to establish to prove prevention of starvation. Hint:  This might consider thinking about how the mutex operators themselves are implemented along with the mechanics of the arbiter solution (5 points)
- The arbiter solution is starvation free due to a few factors. The first of which being that there is only a *single* arbiter. This is important as the arbiter will never have conflicting information, ie. no two philosophers can approach the arbiter and get answers that contradict each other and potentially leading to a deadlock. The single arbiter relies on a mutex lock to ensure that only one philosopher can ask for forks at a time. Since the arbiter will only give forks away if and only if both requested forks are available, there is no possible situation where a philosopher picks up a single fork and is left waiting for the other. In general, this is a fair and efficient solution.

**4**. Once you’ve identified which of your four programs was unfair, examine the code and speculate on how it is interacting with the allocation of resources (chopsticks) to create the unfairness. In other words, _explain_ why philosophers with lower ID numbers seem to get preferential treatment.  Again, a formal proof is not necessary, but you should at the very least show, by discussion, a few examples of how the unfairness arises (5 points).
- This pattern actually depends on how the resource hierarchy solution is implemented. If the philosophers all pick up their low fork first, the *second to last* philosopher will eat significantly more than all the rest. Let's play out an example scenario with 5 philosophers and 5 forks. All philosophers have to pick up their lower fork first, so philosophers 1 through 4 pick up their low fork. Philosopher 5 can't pick up it's low fork because it's being held by philosopher 1 (in this case philosopher 5's high fork is on the opposite side as the rest, it's on their left as opposed to right assuming they're sitting in a clockwise fashion). But in this scenario, the only philosopher who can actually eat is philosopher 4! They're the only philosopher who can actually pick up their higher fork. This leads to philosopher 4 getting a much higher chance of having both forks open most of the time. Since philosopher 3 depends on philosopher 4 to give up their low fork the pattern continues down. The inverse of this situation is where the they pick up high forks first. This creates the trend where lower philosophers tend to eat much more. Let's run through the problem again. Philosophers 1 through 4 pick up their low fork. Meaning they pick up the fork that corresponds to their ID number. Philosopher 5 can't pick up their high fork because philosopher 4 is holding it (fork 4 is greater than fork 1, thus 5's fork is on it's opposite side again as before). So 1 is now the only philosopher who can pick up both their forks. Hence, the lower ID philosophers get priority eating. If 1 eats first, then 2 can eat and so on and so forth. This allows lower forks to eat first in more conflicted situations.