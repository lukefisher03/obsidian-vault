**1.1:** Someone wants to write code that actually has multiple threads CHANGING the contents of c\[] as declared in the sample code.  This person suggests that one can modify the parameter block structure (struct arg) so that pointers to the array c\[]can be sent into each thread.  The person argues that since the each parameter block is unique to each thread, that all should be fine.  Do you agree or disagree with this thinking?  Be SPECIFIC AND DETAILED in your explanation of why you either agree or disagree.
- This is a bad idea and cannot be safe without mutexes or some form of synchronization. It doesn't really matter if distinct pointers to `c` are given to each thread. If those pointers are still de-referenced and then used to mutate the `c` array itself, then there could be possible memory corruption as there's no guarantee of the threads executing in a deterministic order. The only way it would be memory safe is if each thread were given it's own copy of `c` through the `input` struct. But this doesn't accomplish the end goal of having multiple threads modify `c`. There is no safe way to do this without mutexes or synchronization of some kind.

**1.2**: Thread Safe code ([https://en.wikipedia.org/wiki/Thread_safetyLinks to an external site.](https://en.wikipedia.org/wiki/Thread_safety)) is code that will absolutely not cause data corruption to any data structure when it is run it in parallel and/or concurrently with other threads.  Although we will explore this concept in much greater detail in later modules, it is certainly possible to demonstrate that the example code that computes the average of the contents of array c\[] IS thread safe.  Give an explanation, in your own words, of why the function void *sum_array_elements(void *input) is thread safe.  Be detailed in your answer and explain how and why each and every possible memory access made by the function will NOT cause a problem.
- A pointer to a struct is passed into the thread upon creation. In this example, the data passed into each thread isn't shared. Meaning thread 2 isn't passed the same pointer as thread 1, they each have their own `args` struct. Then inside the thread itself, the function copies each parameter from the `input` argument into local variables. This gives us local copies to work with and guarantees that we don't modify the original values. Later on in the function when we loop through `c` there could be potential unintended behavior if `c` were to be modified during this thread's execution. However, in the code provided `c` is never modified. Setting it to const would guarantee thread safety. Then finally we "return" the sum by setting the value inside the `input` struct. This is still memory safe due to the fact that only one thread has access to that data. However, there could potentially be issues if the main thread modified data or if the arguments were passed into another thread. But since `input` is only given to a single thread, there shouldn't be an issue with returning a value through the struct.

**1.3**: Assume that the declaration for the double array c\[] is moved INTO the function main() so that the array is a variable of function main().  Assume no other changes are made.  Will this code still work?  Why or why not.  Explain your answer in terms of process memory models rather than showing us compiler output.
- No, this code will not work. The threads don't access the local variables of the parent. If they had access to the local variables then there wouldn't be much point in passing parameters to the threads on creation. Threads get their own stack, registers and TLS. They have access to global and static variables and heap memory (plus whatever is manually shared between threads).

**1.4:** Assume a programmer allocated heap memory using malloc() in main()and stored the reference to that memory in the global variable memory_pointer.  Clearly child threads cannot safely modify memory_pointer directly without risking data corruption risk.  Can they, however, freely modify the allocated memory that memory_pointer  points to?  Explain your answer in detail and using you knowledge of process memory maps.
- They can modify that data due to the fact that the program's heap memory is available for all threads to see and modify. However, modifying heap memory isn't inherently safe. In order to do safe memory mutation in the heap, the program should employ memory safety techniques such as mutexes or synchronization.