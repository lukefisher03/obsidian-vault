**1. On a system that uses paging, a process cannot access frame memory that it does not own.  Why?   It is possible to make more than process "own" a specific (same) frame in main physical memory.  How could a kernel support multiple processes "owning" the. same frame of physical memory? Why should it this be allowed and what risks would be introduced once it were allowed.  How would separate processes ameliorate these risks?**
A process cannot access a frame that it doesn't own due to the *per-process* page table. Each process has its own page table. So when a virtual address is generated by the CPU, it only looks up the page (and then the frame) from a table of valid pages. If the virtual memory points to an invalid page (either it doesn't exist or is invalid) a trap is triggered and a page fault is processed. Yes it is possible for multiple processes to have page table entires that correspond to the same frame. This can be utilized for shared memory for interprocess communication. In order for two different processes to own the same frame, they would both need to have a page table entry that can decode a virtual address in their respective address spaces that point to the same frame. This could cause corruption if memory is overwritten in unexpected ways or there's synchronization issues. Some of this can be mitigated by utilizing the read/write bits to do a little bit of synchronization or access control. Making a frame read only could eliminate many of the risks.
   
**2. Consider a logical address space of 2048 pages with a fixed 4KB page size mapped onto a physical memory of 512 frames. (10 points)**
m = 11 bits for page number
n = 12 bits for offset
***How many bits are required in the logical address?***  
There are 23 bits required in the logical address. 11 bits for the page number and 12 for the offset.

***How many bits are required in the physical address?***
You need 9 bits to address 512 frames. Then you need 12 bits to to address each offset so in total you need 21 bits.
   
**3. Consider a paging system with the page table stored in memory. (10 points)**
**If a raw, direct, memory reference takes 50 nanoseconds, how long does a paged memory reference take?**  
A paged memory reference would take 100 nanoseconds. 50 nanoseconds to look up the page in the page table and then and then another 50 nanoseconds to access the physical memory. This is normally what happens if a page isn't found in the TLB.

**If we add TLBs and if 75 percent of all page-table references are found in the TLBs, what is the effective memory reference time?  Assume that finding a TLB reference takes 2 nanoseconds if the entry is present.  Show your work and calculations.**
(0.75)(50) + (0.25)(100) = 62.5
75% of the time our memory accesses take 50 nanoseconds when they're found in the TLB. But the other 25% of the time the access takes 100 nanoseconds. So when we add these together we see that the effective memory reference time is about 62.5 nanoseconds.

**4. Under what circumstances to page faults occur?  Describe the actions taken by the OS when a page fault occurs. (10 points)**
A page fault occurs when a process tries to access a page marked invalid. This can be due to the page not being brought into memory. The page fault triggers a trap and the operating system handles the trap. Three primary things happen when handling the page fault. First the OS checks if the address was valid or not from the PCB. If the reference was invalid, then the process gets terminated. If the page was valid but not brought in, then we page it in. Next a free frame is located. Secondary storage reads the page into the new frame. We modify the internal process page table to reflect the new change. The instruction that caused the fault gets restarted. 

**Consider the page table for a system with 12-bit virtual and physical addresses and 256 byte pages. (20 points)**

The list of free page frames is D, E, F.  A dash for a page indicates that the page is not in memory.  Convert the following virtual addresses to their equivalent physical addresses in hexadecimal.  All number are given in hexadecimal.

m = 12 - Address space power
n = 8 - Page size power

Page number bits = 12 - 8 = 4
Offset number bits = 8

1. `9EF - 100111101111`
   Page number: 9, offset: 239
   Physical address: **0xEF**
2. `111 - 000100010001`
   Page number: 1, offset: 17
   Physical address: **0x211**
3. `700 - 011100000000`
   Page number: 7, offset: 0
   **Page fault, not in the table.**
4. `0FF - 000011111111`
   Page number: 0, offset: 255
   **Page fault, not in the table.**

**Consider a demand-paged computer system where the degree of multi-programming is currently fixed at four.  The system was recently measured to determine utilization of the CPU and the paging disk.  Three alternative results are shown below.  For each case, what is happening?  Can the degree of multiprogramming be increased to increase the CPU utilization?  Is the paging helping? (30 points)**

1. CPU utilization = 13% and disk utilization 97%  
   In this case pretty much memory access is page faulting resulting in having to load in pages from secondary memory. This is sometimes called thrashing. No real work is actually getting done. Paging is not helping and degrees of multi-programming should be decreased in order to stop the thrashing.
2. CPU utilization = 87% and disk utilization 3%  
   This is a generally good case. This means that the CPU is processing instructions and since the disk utilization is low that means page faults aren't occurring very often. A performance increase would occur if we added more degrees of multiprogramming. The paging appears to be working just fine and no changes should be made.
3. CPU utilization = 13% and disk utilization 3%
   In this case it just seems like there aren't that many scheduled processes. Since there aren't many processes, the degrees of multiprogramming and the paging are irrelevant. If there is only a single CPU core and its waiting for something, then possibly increasing the degrees of multi-programming could help unblock the waiting that's happening. However, if you increase the degrees of multiprocessing too much then you could risk thrashing if you have a lot of page faults.