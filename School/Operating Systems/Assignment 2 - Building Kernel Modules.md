**1.1**: In your own words, explain what each of the following commands does:  depmod,  insmod, lsmod, modinfo, modprobe, and rmmod. (12 points)

- `depmod`: Each kernel module can export or require symbols. Symbols are services or data that kernel modules can share. `depmod` creates a list of these dependencies for each module and then writes that to `/lib/modules/<kernel_directory>/modules.dep`. A different output directory can be specified if need be. Also it will list all the symbols exported by each module in a file called `modules.symbols`. Alongside each file a hashed binary version is also generated with the suffix `.bin`. 
- `insmod`: This will insert a kernel module. It's simple and doesn't necessarily handle complex dependencies well.  Minimal error messages are generated.
- `lsmod`: This will format the contents of `/proc/modules` to show you the currently loaded kernel modules.
- `modinfo`: Extracts and lists information about a kernel module. If the module name isn't a filename then the kernel directory is searched. Modinfo will list attributes as key value pairs.
- `modprobe`: Intelligently insert modules into the kernel. And by intelligently, we mean that is handles dependencies and loads or removes necessary modules by reading the `modules.dep.bin` file generated by `depmod`. You can also remove modules with the `-r` flag.
- `rmmod`: A simple program to remove kernel modules. `modprobe -r` is a more safe option as it also removes unused dependencies in addition. Removals can be forced with the `-f` flag, but this is dangerous and will only work if the kernel has been compiled with the `CONFIG_MODULE_FORCE_UNLOAD` setting set.

**1.2**: Why might one not prefer to use insmod and rmmod? What would be the alternative to  
these two commands? Explain your answer. (8 points)
	The alternative to these commands is using `modprobe` to insert and including the `-r` flag to remove modules. `insmod` and `rmmod` are trivial in nature and do not properly handle the complexities of many dependencies. There may be hundreds of kernel modules that all create a web of connections. These simple programs ignore this complexity and may be dangerous to use.

**1.3**: Explain how one might modify the Linux system to automatically load named modules  
at boot time? Write directions suitable for instructing another person to accomplish this  
task. (20 points)
	 Normally we rely on other methods for automatic loading of kernel modules. However, we can explicitly list which modules we want to load automatically at boot time by modifying the `/etc/modules-load.d/modules.conf` file and specifically list the names of our kernel modules on each newline. Characters that follow a `#` are ignored.

**2.1**: At one terminal shell prompt, enter: cat /dev/lkm_device. Enter the same thing at the  
terminal prompt in the other window. What did you see? Does this make sense with respect  
to how the module was written? Explain your answer. (2 points)
	 It states that the resource is busy. This makes sense as the device has to be opened and released. In the code there are functions named `device_open` and `device_release`. Inside the device open function it checks a counter of the number of devices that are using the module and returns a `EBUSY` error if the module is in use.
	 
**2.2:** Make sure that the cat from dev/lkm_device command is not running in either window. Once you do, type this at either of the terminal shell prompts: cat | /dev/lkm_device.  What happened?  Do you see any interesting messages in the system log (use dmesg to check).  Does this make sense with respect to how the module was written?  Explain your answer. (2 points)
	 This command appears to be malformed. Breaking it down, it looks like it uses `cat` with `stdout` and then attempts to create a pipe to calling `/dev/lkm_device`. This doesn't work for a few reasons. First of all, pipes allow you to connect the output of one *command* to another via connecting the first command's `stdout` to the next command's `stdin`. However, in this situation `/dev/lkm_device` is treated as a file instead of an executable. Files don't take input from `stdin` and cannot be executed. Thus, the `SIGPIPE` signal is sent to indicate that a write to a broken or invalid pipe occurred and the process terminates. The way the C module was written has no effect on this command. Even if the device driver was configured to allow writes, it wouldn't matter because the process gets terminated due to the broken pipe. And, even if the pipe succeeded, you don't write to device via a pipe operator, you would need to use redirection.
	 ![[Pasted image 20250210082352.png]]
	 
**2.3:** Once the permissions are set on /dev/lkm_device in a manner that would allow a user to send it character input, type this at either of the terminal shell prompts: cat | /dev/lkm_device. What happened? Do you see any interesting messages in the system log (use dmesg to check).  Does this make sense with respect to how the module was written?  Explain your answer (2 points)
	 Changing the permissions on `/dev/lkm_device` doesn't change what's wrong with the command. As shown in the screenshot, all of the device's permissions are unrestricted. All users have read, write, and execute permissions. At the bottom of the output, we see the same thing from the previous question. The write failed due to a broken pipe created by trying to pipe the `stdout` of `cat` into the `stdin` of a non-executable file. Technically speaking, `/dev/lkm_device` really isn't a file. But rather it's a *character device* interface. Since Linux's motto is "everything's a file", we interface with devices via file-like entities. If we want to successfully trigger a write to the device we need to use redirection (`>`). A screenshot of that is shown at the bottom. The write produces the `Invalid argument` error as expected from the C source code that defines behavior when a write syscall. Note that if write permissions are revoked for the file, the write would fail due to insufficient permissions before the actual syscall is processed by the driver.
	 ![[Pasted image 20250210094314.png]]
	 ![[Pasted image 20250210095800.png]]
**2.4:** Send the output of /dev/lkm_device to the screen by typing cat /dev/lkm_device in one terminal window. While the output is being sent to the terminal, try to remove the module from the OTHER terminal window. What happens?  Does this make sense?  Why or why not? (3 points)
	 Removing the module throws an error saying `rmmod: ERROR: Module lkm_module is in use`.
	 
**2.5:** Research the following and answer in your own words: “What exactly are the “major” and “minor” device numbers. What do these number correspond to in either or both of the kernel or the collection of hardware devices that might currently be attached to the system? (3 points)
	 The major number connects the device to the driver. A driver may control more than one device, so the minor number makes sure the driver can identity which device it's operating on.
	 
**2.6:** Research the following and answer in your own words: “Why are global variables and function prototypes defined using the static keyword in the module source?” (3 points)
	 Global variables and function prototypes are defined as static to limit the scope of those variables and functions to the current file.