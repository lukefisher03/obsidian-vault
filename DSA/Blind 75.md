
##### Implement Queue using Stacks ⭐️
Implement queue using 2 stacks. The first stack contains all of the elements in their queue order. When we need to peek the queue we just look at the first element of the stack. If we need to pop, then we translate the first stack to the second and then pop the last element (which was previously the front of the queue due to the reversal after popping elements). Then we can refill the first stack to restore the original order.

*Follow up optimization*
If you do the naive way of transferring all of the elements from stack 1 to stack 2, popping the last element from stack 2, and then re-transferring the elements back to stack 1, you end up with a O(2n) time complexity. Doing the second transfer is technically extraneous. Suppose you pop more than 1 element at once. You would do 2 pops before returning the stack. Well, what if instead you didn't do the second transfer. Then, when peeking, you could just look at the last element of stack 2 if it has elements, otherwise the first element of stack 1. Then when dequeueing you would only have to perform an O(1) pop operation most of the time. It has *amortized* O(1) time. Meaning that occasionally, there may be a higher time complexity, but when that higher time complexity is reduced over the other events it's time complexity is O(1). 

##### First Bad Version ⭐️
Given a number *n* representing consecutive versions of a product 1 - n, find the first bad version using API function *isBadVersion(version)*. Because all versions are based on their predecessors, one bad version corrupts all following versions. The intuition here is to use Binary Search. This will result in fewer calls to the API than a linear search. It will cut the time complexity down from O(n) to O(log n). Keep track of a low and a high number. This keeps track of what numbers are cut out of the search space. Loop until the low and high variables converge to a single number. In each iteration check if the midpoint number is a bad number. If it is, then you know that all numbers greater than that number are also bad. Move the high variable to one before the calculated midpoint. If the number isn't a bad number, then set the low variable to one greater than the midpoint. You know that all numbers before the midpoint will be good numbers so you can cut them out of the search space. Once the low and high variables have the same value, then you know you've converged onto the first bad version.

##### Ransom Note
You are given two strings `ransomNote` and `magazine`. You need to find whether or not the letters in magazine could be re-ordered to make the ransom note. The magazine may contain more letters than the ransom note. The initial intuition for this problem is to use a hash map. You need to count the occurrences of each letter in magazine. Then you iterate through the ransom note making sure the magazine contains the same letters with at least the same occurrences. A good way to do this without too much extra space is to subtract 1 each time you find a letter in magazine when looking at the ransom note. Then if any letter's counter is below zero, then you know that the ransom note can not be built from the magazine.

##### Climbing Stars ⭐️
The trick here is to recognize that the solution pattern is fibonacci sequence. When you climb 5 stairs there are 8 different possibilities. This is because 8 is the 5th fibonacci number. Keep track of a previous and current variable and then a total variable. If there are n steps, then you need to calculate the nth fibonacci number. Recursion is too slow, use DP or iteration to calculate the number. This is a fundamental DP problem where you can use either bottom up or top down DP.

##### Longest Palindrome
The problem is relatively simple. There really isn't a trick to it other than just being observant of how palindromes work with odd and even lengths. The solution involves counting occurrences of each character and then strategically summing up the counts. For each even number add it to the running sum. If there's an odd number add it to the count but then for all future odd numbers, subtract one before adding it.

##### Reverse Linked List ⭐️
Given a linked list, reverse it and return the reversed list. This problem can be solved iteratively and recursively. For the iterative solution, the intuition is relatively simple. We need to reverse the direction of the pointers for each element in the list. We can do this using two pointers and then keeping track of which node to go to next after reversing the direction of a connection between previous nodes. The recursive solution leverages the recursive call stack and runs with O(n) time and space.

##### Majority Element ⭐️
The obvious answer to this problem just involves using a hash map to keep track of the counts for each nth element. However, a more optimal solution is available. This problem uses the Boyer-Moore voting algorithm. The Moore algorithm allows us to find a majority element in Linear time and constant space. Keep track of 2 variables. One storing the candidate for majority element and the other storing a counter variable. Initially set the candidate variable to the first element. Then iterate through the rest of the array. If the nth number is equivalent to the candidate variable, then increment the counter. If it is not, then decrement the counter. If the counter drops below zero, then you know that the candidate is no longer the majority element so you can reassign it to be the nth number. Finally, after iterating through the entire array, then you can return the candidate variable which will contain the majority element. [Algorithm explained](https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/)